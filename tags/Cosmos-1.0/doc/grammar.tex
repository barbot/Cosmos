\documentclass[a4paper]{article}
\usepackage{bnf}
\usepackage{palatino}

\usepackage[T1]{fontenc} 
\usepackage{geometry}       



\title{Cosmos 1.0 Input File Grammar}

\author{Hilal Djafri}
\date{}




\begin{document}
\maketitle 


\section{Syntax }
\label{syntax.cosmos}
\paragraph{Generic Syntax}
Let us start by the  grammar of some common symbols before giving the grammar of each input file.

A natural number <Integer>, a  real number <Real> or string type <Str> are defined like this:
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<Integer>: [0-9]+; [0-9]* .
<Real>:  ([0-9]+; [0-9]*\.[0-9]+)([eE][-+]?[0-9]+)? .
<Str>: [a-zA-Z][a-zA-Z\_0-9]* .
\end{grammar}

All the symbols finishing by "\textbf{Tag}" refer to a tag of an object. These symbols are string type :
\begin{itemize}
\item <IConstTag>: A tag of a natural number constant.
\item <RConstTag>: A tag of a real constant.
\item <PTag>: A tag of a Petri net place.
\item <TTag>: A tag of a Petri net transition.
\item <LTag>: A tag of an automaton location.
\item <VTag>: A tag of an automaton variable.
\end{itemize}


It is useful to define some integer constants <IConstant>  or real constants <RConstant> which can be used by other definitions:

\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<IConstant> : "const" "int" <IConstTag> "=" <Integer> ";".
<RConstant> : "const" "double" <RConstTag> "=" <Real> ";".
\end{grammar}

Some numerical attributes (marking values, transitions parameters, arcs multiplicity, variables rate, etc.) may be introduced as  a function of 
numerical values (real and/or integer),  constants and/or Petri net places. Let us give the grammar of such functions:

The first kind of these function is <RFormula> for real formula. It intervenes numerical values (integer or real) 
and constants (integer or/and real).
 \begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<RFormula> : <Real> ;   <RConstTag> ; <IFormula> ; <RFormula> <ArOP> <RFormula> ;  "(" <RFormula> ")".
\end{grammar}

The second kind is  <IFormula> for integer formula. It intervenes numerical values (integer or real) 
and constants (integer or/and real) but its value should be  always a natural number. 
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<IFormula> : <Integer> ; <IConstTag> ; <IFormula> <ArOpRes> <IFormula>  ; "(" <IFormula> ")" ; 
"floor" "(" <RFormula> ")".
\end{grammar}


The third kind of functions is <MRFormula> for marking real formula.  It intervenes numerical values (integer or real), constants 
(integer or/and real) and Petri places.
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<MRFormula> : <PTag> ; <RFormula> ;  <MRFormula> <ArOp> <MRFormula>; "(" <MRFormula> ")".
\end{grammar}

The last type of functions is <MIFormula> for marking integer formula. It intervenes numerical values (integer or real), constants 
(integer or/and real) and Petri places but its value should be always a natural number.
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<MIFormula> : <PTag> ; <IFormula> ;  <MIFormula> <ArOpRes> <MIFormula> ;"(" <MIFormula> ")" ; "floor" "(" <RFormula> ")".
\end{grammar}

These, functions are defined with this set of  arithmetic operators <ArOp> or a its restricted set <ArOpRes> :
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<ArOp> : "+" ; "-" ; "*" ; "/" ;  "$\hat{~}$".
<ArOpRes> : "+" ; "-"; "*";  "$\hat{~}$".
\end{grammar}


\paragraph{GSPN Syntax}
\label{gspn_syntax}
The definition of the  Petri net consists of:

\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<GSPN>: \{<IConstant> \} \{<RConstant>\} <NT> <NP>  <PList> <TList> <InitMarking> <TransitionsDef> [<InArcs>] [<OutArcs>] [<InhibArcs>].
\end{grammar}

In the first part, some integer and/or real constants can be declared. 
The size of the Petri net (number of transitions and places) must be declared.   
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<IConstant> : "const" "int" <IConstTag> "=" <Integer> ";".
<RConstant> : "const" "double" <RConstTag> "=" <Real> ";".
<NT> : "NbTransitions" "=" <Integer> ";" ; "NbTransitions" "=" <IFormula> ";".
<NP> : "NbPlaces" "=" <Integer> ";" ; "NbPlaces" "=" <IFormula> ";".
\end{grammar}

Then, the set of transitions and places must defined:
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]

<PList> : "PlacesList" "=" "\{" <PTags> "\}" ";".
<PTags> : <PTag> ; <PTags> "," <PTag>.
<TList> : "TransitionsList" "=" "\{" <TTags> "\}" ";".
<TTags> : <TTag> ; <TTags> "," <TTag>.
\end{grammar}

After that, the initial marking is given. By default all the places contain zero token.
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<InitMarking> : "Marking" "=" "\{" <Inits> "\}".
<Inits> : <Init> ; <Init> "," <Inits>.
<Init> : "(" <PTag> "," IFormula ")".
\end{grammar}

The next step consists of a complete description of the transitions. Note that transitions
which  exponentially  distributed will be defined differently from  those with other distributions.
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<TransitionsDef> : "Transitions" "=" "\{" <Transitions> "\}" ";".
<Transitions> : <Transition > ; <Transitions> "," <Transition>.
<Transition> : <Exp> ; <NonExp> .
\end{grammar}

A transition with an exponential distribution can be marking dependent parameter. 
A priority and a weight will be given. A service policy will be chosen. 
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<Exp> : "(" <TTag> "," "EXPONENTIAL" "(" <MRFormula> ")" "," <Priority> "," <Weight>  "," <Service> "," <Memory>  ")"
;"(" <TTag> "," "EXPONENTIAL" "(" <MRFormula> ")" "," <Priority> "," <Weight>  "," <Service> ")".
<Service> : "SINGLE" ; "INFINITE" ; "MULTIPLE" "("<integer>")".
<Memory> :  "ENABLEDMEMORY" ; "AGEMEMORY".
\end{grammar}

A transition with non exponential distribution can't be marking dependent parameters. 
A priority and weight will be given. There is no service policy to chose (the only possible is single service). 
Then  A memory policy can be chosen, by default the policy is enabled memory:  
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<NonExp> :  "(" <TTag> "," <Dist> "," <Priority> "," <Weight> "," <Memory>  ")" ; 
"(" <TTag> "," <Dist> "," <Priority> "," <Weight>  ")" .
<Dist> : "IMMEDIATE"; "DETERMINISTIC" "(" <Real> ")" ; "UNIFORM" "(" <Real> "," <Real> ")"
"ERLANG" "(" <Integer> "," <Real> ")" ; "GAMMA" "(" <Real> "," <Real> ")" ; "TRIANGLE" "(" <Real> "," <Real> "," <Real> ")"; 
"GEOMETRIC" "(" <Real> "," <Real> ")" ; "LOGNORMAL" "(" <Real> "," <Real> ")".
\end{grammar}

The final part consists of introducing the different matrices of the net. Note that the arcs multiplicity can be marking dependent. 
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<In> : "InArcs" "=" "\{" <InArcs> "\}" ";". 
<InArcs> : <InArc> ; <InArcs> "," <InArcs>.
<InArc> : "(" <PTag> "," <TTag> ")" | "(" <PTag> "," <TTag> "," <MIFormula> ")".
<Out> : "OutArcs" "=" "\{" <OutArcs> "\}" ";". 
<OutArcs> : <OutArc> ; <OutArcs> "," <OutArcs>.
<OutArc> : "(" <TTag> "," <PTag> ")" | "(" <TTag> "," <PTag> "," <MIFormula> ")".
<Inhib> : "InhibArcs" "=" "\{" <InhibArcs> "\}" ";". 
<InhibArcs> : <InhibArc> ; <InhibArcs> "," <InhibArcs>.
<InhibArc> : "(" <PTag> "," <TTag> ")" | "(" <PTag> "," <TTag> "," <MIFormula> ")".
\end{grammar}




\paragraph{HASL Syntax}
\label{hasl_syntax}

The definition of the  HASL formula consists of:
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<HASL> : \{<IConstant> \} \{<RConstant>\} <NL> <NV>  <LList> <VList> <Expression> <InitLoc> <FinalLoc> <LocDef> [<Edges>].
\end{grammar}

In the first part some constants can be declared. The number of locations and variables must be given.
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<IConstant> : "const" "int" <IConstTag> "=" <Integer> ";".
<RConstant> : "const" "double" <RConstTag> "=" <Real> ";".
<NL> : "NbLocations" "=" <Integer> ";" ; "NbLocations" "=" <IFormula> ";".
<NV> : "NbVariables" "=" <Integer> ";" ; "NbVariables" "=" <IFormula> ";".
\end{grammar}

Then set of locations and variables will be declared:
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<LList> : "LocationsList" "=" "\{" <LTags> "\}" ";".
<LTags> : <LTag> ; <LTags> "," <LTag>.
<VList> : "VariablesList" "=" "\{" <VTags> "\}" ";".
<VTags> : <VTag> ; <VTags> "," <VTag>.
\end{grammar}

Then the hasl expression will be introduced:
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]

<ExpectExp> : "AVG" "(" <F> ")" ";".
<F> : <H> ; <F> "/" <RFormula> ; <F> "*" <RFormula> ;       
      <F> <ArOp> <F> ; 
      "min" "(" <F> "," <F> ")" ; "max" "(" <F> "," <F> ")" .
<H> : "Last" "("<LX> ")" ;  "Min" "("<LX> ")" ; "Max" "("<LX> ")" ; "Integral" "(" <LX> ")" ; "Mean" "(" <LX>  ")" ; "Var" "("<LX> ")" .
<LX> : <term> ; <term> "+" <term> ; <term> "-" <term> .
<term> : <VTag> ; <Real> "*" <VTag> ; "("<MRFormula>")" "*" <VTag>.
\end{grammar}

The set of initial and final locations will be given:
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<InitLoc> : "InitialLocations" "=" "\{" <LTags> "\}" ";".
<FinalLoc> : "FinalLocations" "=" "\{" <LTags> "\}" ";".
\end{grammar}

Then, the locations will be completely described. Each location is tagged with <LTag> and satisfies  a property on the  marking of the Petri net.
At each location, the rates of the variables are given. By default rates are set to zero.
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<LocDef> : "Locations" "=" "\{" <Ldefs> "\}" ";".
<Ldefs> :  <Ldef> ; <Ldefs> "," <Ldef>.
<Ldef> : "(" <LTag> "," <MLFormula> "," "(" <Vrates> ")" ")".

<MLFormula> : "TRUE" ; <MRFormula> <CompOp>  <MRFormula> ; <MLFormula> <LogOp> <MLFormula> ; "!" "(" <MLFormula> ")".
<CompOp> : "=" ; ">" ; "<" ; ">=" ; "<=" .
<LogOp> : "\&" ; "|".

<Vrates> : <Vrate> ; <Vrates> "," <Vrate> .
<Vrate> : <VTag> ":" MRFormula .
\end{grammar}


Finally, the edges will be defined. An edge relies a location source to a location target ( <LTag> , <LTag> ). 
Each edge is associated to a set of Petri net transitions <Actions>. If the edge is synchronized with all Petri transitions then
<Actions> will take value "ALL". If the edge is not synchronized with the Petri net (i.e an autonomous edge) then <Actions> will take 
value "\#". Each edge is associated to a set of linear constraints on automaton variable <Constraints>. If the edge is not subject  to any 
constraint then <Constraints> will take value "\#". Each edge is also associated to a set of variable updates <Ups>. If no update is required then 
<Ups> will take value "\#". 
\begin{grammar}
[(colon){$::=$ }]
[(semicolon){$|$ }]
%[(comma){\{\}} ]
[(period){\\ }]
[(quote){"}{" }]
[(nonterminal){$\langle$}{$\rangle$ }]
<Edges> : "Edges" "=" "\{" <Edefs> "\}" ";".
<Edefs> : <Edef> ; <Edefs> "," <Edef> .
<Edef> : "(" "(" <LTag> "," <LTag> ")" "," <Actions> "," <Constraints> "," <Updates> ")".
<Actions> : "\#" ; "\{" <PTags> "\}" ; "ALL" "\\" "\{" <PTags> "\}".
<Constraints> : "\#" ; Constraint ; Constraint "\&" Constraints .
<Constraint> : <LX> "=" <MRFormula> ; <LX> ">=" <MRFormula> ; <LX> "<=" <MRFormula> .
<Updates> : "\{" <Ups> "\}" ";" .
<Ups> : <Up> "," <Ups> .
<Up> : <VTag> "=" <VMRFormula>;
<VMRFormula> : <VTag> ; <MRFormula> ; <VMRFormula> <ArOp> <VMRFormula>.
\end{grammar}
\end{document}

